## 无符号与有符号数

​	在计算机中,无符号和有符号都是用二进制表示,任意一个二进制数我们都可以视为一个0,1为元素的向量,例如101011可视为[1,0,1,0,1,1]这样的向量,或者说映射为向量形式
&nbsp;&nbsp;&nbsp;&nbsp;**即:** $$ x \rightarrow [x_{n-1},x_{n-2},...,x_{1},x_{0}] $$   其中$$x_i$$的值为0或1

1. ### 无符号二进制数

​    在无符号数的二进制表示中,我们依然可是使用映射的方式来看待,那么向量$$[x_{n-1},x_{n-2},...,x_1,x_0]$$转换为实际的数算法如式子(1)
$$
x_n^u=\sum^{n-1}_{i=0}{x_i2^i}
$$
式子(1)中的$$2^i$$为权重,$$x_i$$为权重的系数

式子(1)说明了一个$$[x_{n-1},x_{n-2},...,x_1,x_0]$$的二进制形式向量表示的数的大小,那么如何将一个10进制的数或者说任意R进制的数转换为2进制(或者说任意的S进制(S>=2))

在10进制下,例如:数1234可以看作$$[1,2,3,4]$$这样的向量,4的权重为$$10^0$$,3的权重为$$10^1$$,依次类推

那么$$1234=1*10^3 + 2 * 10 ^2 + 3 * 10^1 + 4 * 10^0$$

同样的我们用映射的角度来看
$$
[r_{n-1},r_{n-2},...,r_1,r_0] == [s_{m-1},s_{m-2},...,s_1,s_0]
$$
式子(2)表明
$$
\sum^{n-1}_{i=0}{r_iR^i} = \sum^{m-1}_{j=0}{s_jS^j} = \sum^{m-1}_{j=1}{s_jS^j}+s_0\\
=>t = \sum^{n-1}_{i=0}{r_iR^i}  \\
s_0 = t \,\,\% \,\,S \,\,\,\,\,\,\,\,\,\,t = t /S \,\,=\sum^{m-1}_{j=1}{s_jS^{j-1}}\\
s_1 = t \,\,\% \,\,S \,\,\,\,\,\,\,\,\,\,t = t /S \,\,=\sum^{m-1}_{j=2}{s_jS^{j-2}}\\
...\\
s_m = t \,\,\% \,\,S \,\,\,\,\,\,\,\,\,\,t = t /S \,\,=\sum^{m-1}_{j=m}{s_jS^{j-m}}\\
$$
式子(3)就是任意进制之间的转换算法(无符号的)

对于无符号数的加法
$$
x_n^u+y_n^u=\sum^{n-1}_{i=0}{(x_i+y_i)2^i}\\
x_n^u-y_n^u=\sum^{n-1}_{i=0}{(x_i-y_i)2^i}
$$
​	由于$$x_i+y_i$$可能值为{0,1,2},当为2是就会向$$i+1$$位进位,同理$$x_i-y_i$$也会存在借位的情况,运算逻辑和十进制一致,由于借位和进位的存在会导致 a + b的值会小于 a,b 

​	在n位的无符号二进制之中,表示的数的范围$$[0,2^n-1]$$,当x+y的值大于了 $$2^n-1$$时就会存在溢出的问题,也就是x+y实际会变为n+1位的二进制,对于无符号二进制来说,溢出后就会直接舍弃溢出位,保留剩下的n位数据 $$x+y \rightarrow[x_n,x_{n-1},...,x_1,x_0]$$忽略掉进位$$x_n$$,

​	当$$x-y<0$$时,会存在借位向第n位借位的情况,同样忽略掉最高位的借位

##### 扩展与截断

​	在编程过程之中,常常会存在数据的扩展和截断问题

```c++
uint8_t ch = 0xFE;
if( 0xFE == ch ){
    /// 执行某些操作
}
```

​	在上面的代码中,0xFE被视为32位无符号二进制数,而ch是8位无符号二进制,那么在比较时,ch会被扩展位32位的数进行比较,将执行if语句之中的代码

```C++
int8_t ch = 0xFE;
if( 0xFE == ch ){
	/// 执行某些操作
}
```
​	在上面的代码中,ch的值0xFE但是并不会进入if语句之内,错误的原因也是由于数据的扩展导致

​	

2. ### 有符号二进制数

&nbsp;&nbsp;&nbsp;&nbsp;在计算机中,有符号数据通常有三种表示方式,**原码**,**反码**和**补码**,在原码之中,最高位为符号位(0为正,1为负),这种表示在进行加减运算时不方便,反码在进行加减运算时方便,但是0的表示却有+0和-0之分,因此才有了补码
&nbsp;&nbsp;&nbsp;&nbsp;在理解补码时面临的最大问题就是符号位参与运算(以及如何运算),这是补码最难理解的地方

#### 原码
$$
x_n^t = (-1)^{x_{n-1}}*\sum^{n-2}_{i=0}{x_i2^i}
$$

​    在原码的表示之中,$$x+y$$就无法向无符号数那样方便运算

#### 补码

$$
x_n^t=-x_{n-1}2^{n-1} + \sum^{n-2}_{i=0}{x_i2^i}
$$

​	在补码之中$$n-1$$位的权重是 $$-2^{n-1}$$,其余位的权重是 $$2^{i}$$,在这种表示方式之中,最高位$$x_{n-1}$$不用看作符号位,和其余位相同(只是权重变为负数而已),由于$$\sum^{n-2}_{i=0}{x_i2^i}$$的最大值位 $$2^{n-1}-1$$,n位补码的最大值为$$2^{n-1}-1$$,而最小值就是当$$x_{n-1}$$为1其余$$x_i$$都为0时(100...00这种二进制)的值$$2^{n-1}$$,这样看来负数的个数就比正数多1个(当我们把0视为正数时负数个数和正数个数就相同),而从形式上的表现来看,最高位为1时为负数,为0时为正数

​	那么一个有符号的数(如-123)转换为n位的,用补码表示的二进制时该怎么来计算呢?

​	

#### 补码的加减法

$$
x_n^t+y_n^t=-(x_{n-1} + y_{n-1})2^{n-1} + \sum^{n-2}_{i=0}{(x_i+y_i)2^i}\\
x_n^t-y_n^t=-(x_{n-1} - y_{n-1})2^{n-1} + \sum^{n-2}_{i=0}{(x_i-y_i)2^i}
$$



​	在式子(6)之中,补码的减法依旧是减法的逻辑,现将减法转变为加法处理

​	式子(6)可转变为式子(7)
$$
x_n^t-y_n^t=-(x_{n-1} + 1 - y_{n-1})2^{n-1} + \sum^{n-2}_{i=0}{(x_i-y_i)2^i} + 2^{n-1}
$$
将$$2^{n-1}$$合并到$$\sum^{n-2}_{i=0}{(x_i-y_i)2^i}$$之中就变为了 $$\sum^{n-2}_{i=0}{(x_i+1-y_i)2^i}+1$$(加1的原因是 $$\sum^{n-2}_{i=0}{2^i}=2^{n-1}-1$$)

式子(9)也转变成了式子(10)
$$
x_n^t-y_n^t=-(x_{n-1} + 1 - y_{n-1})2^{n-1} + \sum^{n-2}_{i=0}{(x_i+1-y_i)2^i} + 1
$$
式子(10)之中的 $$1-y_{i}$$就相当于对$$y_i$$取反操作,即
$$
y^`_i=\begin{cases}
0 &y_i=1\\
1 &y_i=0
\end{cases}
$$
式子(10)也就可以写为
$$
x_n^t-y_n^t=-(x_{n-1}+y^`_{n-1})2^{n-1}+\sum^{n-2}_{i=0}{(x_i+y^`_i)2^i}+1
$$
也就变成了常说的取反加1的逻辑,将减法变为了加法
$$
x_n^t-y_n^t=x_n^t+y_n^{'t} +1
$$


补码的扩展与截断

